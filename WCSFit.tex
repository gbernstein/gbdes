% Documentation for the WCSFit.cpp object-matching program.
\documentclass[11pt,preprint,flushrt]{aastex}
\usepackage{amsmath}
\def\eqq#1{Equation~(\ref{#1})}
\newcommand{\bfx}{\mbox{\bf x}}
\newcommand{\bfu}{\mbox{\bf u}}
\newcommand{\bfa}{\mbox{\boldmath $\alpha$}}
\begin{document}

\title{Documentation for {\tt WCSFit} Code}

\author{G. M. Bernstein}
\affil{Dept. of Physics \& Astronomy, University of Pennsylvania}
\email{garyb@physics.upenn.edu}
\date{13 June 2013}

\section{Concepts}
{\tt WCSFit} adjusts the parameters of astrometric maps to minimize the disagreements between sky positions derived from different exposures of the same objects.  The list of matched detections is taken from the {\tt WCSFoF} output file.  This file contains links to the original catalog files, from which further information on each detection can be extracted.  

\begin{itemize}
\item {\it Detection:}  An observation of a sky object, with a position and a position uncertainty given in pixel units.  
\item {\it Match:} A group of detections that are expected to represent the same sky object and hence have the same coordiantes after mapping to the sky.
\item {\it Field:} The sky is divided into fields.  Each detection is assigned to one field; coordinate matching is done in the gnomonic projection about the center of the field.  A list of fields and their centers is provided in the input file from {\tt WCSFoF}. 
\item {\it Extension or Catalog:} An input catalog of detections.  Catalogs are read from FITS binary tables (probably either generated by SExtractor or encapsulating a reference catalog).  Each FITS bintable extension is considered a distinct input catalog.  Each extension is assigned to one field, and must have some input world coordinate system (WCS) map into celestial coordinates.  An initial WCS map is given in the input file; {\tt WCSFit} will refine the parameters of this or some other functional form.
\item {\it Exposure:} Each extension is assumed to come from one exposure of the sky (a reference catalog would be considered a single exposure).  All extensions from a given exposure must be in the same field.  
\item {\it Instrument:} Each exposure is assumed to have been taken with a single instrument.  The astrometric solution will have a component that is fixed for the instrument, followed by a remapping particular to each exposure.
We would want to have a different instrument for each filter of a given camera.  We may wish to assign different instruments for different runs of the same camera if we suspect the alignment changed between runs. 
\item {\it Device:} An instrument can have multiple devices ({\it e.g. CCDs}).  Each device has its own pixel coordinate system and a distinct WCS.  It is assumed that every extension (input catalog) is from a single device of a single exposure with a single instrument.
\item {\it Reference} and {\it Tag} catalogs:  An input catalog (extension) is a {\it reference} if its position information is considered known and included in the $\chi^2$ of the global fitting, but there is no re-fitting of the WCS to be done for this exposure.  A {\it tag} catalog contains information (such as color) that we want associated with a match, but the object positions are not used at all in the fitting process.  Reference and tag extensions are assigned special instrument ID's.
\item {\it Clipping:} The program alternates rounds of $\chi^2$ minimization with outlier rejection.  Objects more than some multiple of their uncertainty away from the mean sky position of its matched detections are discarded; we expect at least a few percent of object detections to be outliers because of cosmic rays and detector defects, proper motion (e.g. minor planets!), binaries, etc.
\item {\it Reserved matches:} One can request that a fraction of input matches be withheld from the $\chi^2$ calculation used to optimize the WCS.  The statistics of the reserved objects are calculated at the end of {\tt WCSFit} to allow for validation of the fit.
\end{itemize}

Each extension has a map from pixel to sky coordinates composed of two parts: first, an {\em instrument solution}, which gives for each device of an instrument a map from pixel coordinates to an intermediate system nominally centered on the optic axis.  This is then compounded with an {\em exposure solution} which maps from this intermediate system to a gnomonic projection on the sky about the central coordinates for the exposure.  These sky coordinates are reprojected into a common gnomonic projection about the field center for purposes of comparing sky positions of detections within a match.

There is a flexible grammar for specifying the functional form of the instrument solutions.  The exposure solutions are polynomials of a chosen degree.  The {\tt WCSFit} configuration parameters allow selected parameters of the WCS maps to be fixed at input values instead of being optimized.

\begin{itemize}
\item {\it Canonical exposure:} there is often a degeneracy between the exposure solution and the instrument solutions.  To break this degeneracy, each instrument must have a canonical exposure for which we define the exposure solution to be the identity map.
\end{itemize}


\section{Structures}

\subsection{\tt Detection}
A {\tt Detection} is a single measurement of an object position (defined in {\it Match.h}).
\begin{itemize}
\item {\tt catalogNumber} identifies which input catalog this came from.
\item {\tt objectNumber} identifies the object uniquely in the input catalog.
\item {\tt xpix, ypix, sigmaPix} give the detected position and the uncertainty in each coordinate (assuming a circular error region). 
\item {\tt xw,yw} are the position in the gnomonic projection of the field.  These are derived quantities, recalculated on each iteration of the fit.
\item {\tt clipsqx, clipsqy} are the inverse squares of the propagation of the {\tt sigmaPix} error through the WCS map.  They are used to determine whether the {\tt Detection} is to be clipped as an outlier.
\item {\tt wtx, wty} are the weights of this {\tt Detection} in the $\chi^2$ calculation.  They are nominally $1/\sigma^2$ in the world coordinate system, but an exposure can have its weights further scaled by a designated quantity.  Weights of zero indicate that the {\tt Detection} does not ever contribute to $\chi^2$ (such as for a tag).
\item {\tt itsMatch} is a pointer to the {\tt Match} (if any) containing this {\tt Detection}
\item {\tt map} is a pointer to the WCS function used to map this {\tt Detection} into the field's world coordinate system.
\item {\tt isClipped} is set to {\tt true} if this {\tt Detection} is to be ignored in the calculation of $\chi^2$.
\end{itemize}

\subsection{\tt Match}
This class contains a list of detections all presumed to have the same true sky coordinates (defined in {\it Match.h}).  An {\tt iterator} to this list is defined as well as the {\tt begin()} and {\tt end()} functions needed for iteration over the list.  A {\tt Match} is constructed with a pointer to its first {\tt Detection}.  Whenever {\tt Detection}s are added to or removed from a {\tt Match}, the {\tt Detection.itsMatch} member is updated.  Adding a {\tt Detection} resets {\tt isClipped=false}.

Member functions that maintain the membership list and conditions are:
\begin{itemize}
\item {\tt add(Detection* e), remove(Detection* e)} add or remove a chose detection from the {\tt Match}.
\item {\tt erase(iterator i)} removes a {\tt Detection} referenced by the iterator from the {\tt Match}, optionally deleting the detection at the same time.  Returns an iterator to the next object on the list after the erasure.
\item {\tt clear()} removes all {\tt Detection}s from the {\tt Match}, optionally deleting them.
\item {\tt size(), fitSize()} return the number of {\tt Detection}s in the {\tt Match} and the number that will contribute to $\chi^2$, respectively. 
\item {\tt setReserved(), getReserved()} mark and report whether this {\tt Match} should be reserved from the fitting process.
\end{itemize}

The member functions below execute the mapping and fitting functionality for this {\tt Match}.
\begin{itemize}
\item {\tt remap()} recalculates the $({\tt  xpix,ypix})\rightarrow({\tt xw,yw})$ mapping for each {\tt Detection}, using whatever parameters are currently held by the WCS classes.
\item {\tt centroid(double\& x, double\& y, double\& wtx, double\& wty)} reports the centroid and total weight for all the unclipped members $i$ of the match.
\begin{align}
{\tt wtx} & = \sum_i {\tt wtx}_i \\
{\tt x} & = \frac{ \sum_i {\tt xw}_i \cdot{\tt wtx}_i}{\tt wtx}.
\end{align}
\item {\tt chisq(int\& dof, double\& maxDeviateSq)} returns the $\chi^2$ contribution of the unclipped {\tt Detections}.  
It also updates the count of degrees of freedom {\tt dof} and the most significant deviation {\tt maxDeviateSq}. If the number of unclipped {\tt Detections} contributing the $\chi^2$ is $\le 1$, this routine returns zero and leaves its arguments unchanged, as there are no position deviations from the mean.  The return value is
\begin{equation}
\label{chisq}
\chi^2 = \sum_i \left[ \left({\tt xw}_i-{\tt x}\right)^2\cdot {\tt wtx} + \left({\tt yw}_i-{\tt y}\right)^2\cdot {\tt wty}\right].
\end{equation}
The input value of {\tt dof} is incremented by $2(N_{\rm fit}-1)$, with $N_{\rm fit}$ the number of {\tt Detections} contributing to $\chi^2$.  The value of {\tt maxDeviateSq} is set to the maximum of its input value and the largest value of the summand in (\ref{chisq}).
\item {\tt accumulateChisq()} is the primary method used for fitting WCS models to the data.  The method does the following:
\begin{itemize}
\item If there are $N_{\rm fit}\le1$ unclipped detections to be fit, returns 0 and does not alter its arguments. Otherwise it will return the number $2(N_{\rm fit}-1)$ of degrees of freedom, after updated its arguments as follows.
\item The maps to ${\tt xw}_i,{\tt yw}_i$ for each detection are recalculated using the current WCS parameter set ${\bf p}$, as well as the derivatives $\partial{\tt xw}_i/\partial{\bf p}, \partial{\tt yw}_i/\partial{\bf p}$.
\item The input scalar {\tt chisq} is augmented by the $\chi^2$ value in (\ref{chisq}).
\item The input vector {\tt beta} is augmented as
\begin{equation}
\label{beta}
{\tt beta}_i -= \sum_j \left[ \frac{\partial( {\tt xw}_j - {\tt x})}{\partial p_i} \left({\tt xw}_j - {\tt x}\right) {\tt wtx}_j
 + \frac{\partial( {\tt yw}_j - {\tt y})}{\partial p_i} \left({\tt yw}_j - {\tt y}\right) {\tt wty}_j \right]
\end{equation}
\item The input symmetric matrix {\tt alpha} is augmented as
\begin{equation}
{\tt alpha}_{ij} += \sum_k \left[ \frac{\partial( {\tt xw}_k - {\tt x})}{\partial p_i}\frac{\partial( {\tt xw}_k - {\tt x})}{\partial p_j}{\tt wtx}_k
 + \frac{\partial( {\tt yw}_k - {\tt y})}{\partial p_i}\frac{\partial( {\tt yw}_k - {\tt y})}{\partial p_j}{\tt wty}_k \right]
\end{equation}
\end{itemize}
Note that this updating of the $\alpha$ matrix is accomplished in a special {\tt AlphaUpdater} class, which skips all the terms in the matrix that are unaffected by this {\tt Match} and also allows multithreaded increments to the matrix.  The quantities $\alpha$ and $\beta$ are those needed to solve the linearized $\chi^2$ minimization through the normal equation.
\item {\tt sigmaClip(double sigThresh)} executes one round of sigma clipping on the {\tt Match}.  After recalculating the centroid {\tt x,y} of the unclipped {\tt Detection}s, we find
\begin{equation}
{\tt devSq} \equiv \max\limits_i \left[ \left({\tt xw}_i-{\tt x}\right)^2\cdot {\tt clipsqx} + \left({\tt yw}_i-{\tt y}\right)^2\cdot {\tt clipsqy}\right].
\end{equation}
If ${\tt devSq} > {\tt sigThresh}^2$, then the {\tt Detection} with the maximum deviation is marked as clipped and the method returns {\tt true}.  Optionally this also triggers deletion of the clipped {\tt Detection}.
\item {\tt clipAll()} marks all {\tt Detection}s of the {\tt Match} as clipped.
\end{itemize}

\subsection{\tt Instrument}
An {\tt Instrument} has a {\tt name} and has a vector of the {\tt Device}s that make it up.  The class is a {\tt NameIndex} that allows the devices to be indexed either by their numbers or names.  The {\tt addDevice()} call adds devices to the {\tt Instrument}.  The {\tt mapNames} string vector holds the name of the instrument map portion of the WCS for each device---this name is a key for retrieving the map from a {\tt PixelMapCollection} (see the {\em PixelMap} documentation).
For each device we also keep track of the bounds of its pixel space ({\tt domains} vector).

\subsection{\tt Exposure}
The {\tt Exposure} class describes a single exposure.  It has a name.  The {\tt field} and {\tt instrument} integers are indices saying which field and instrument were used for this exposure.  The coordinate map for this exposure is accessed from the {\tt PixelMapCollection} using the string key {\tt mapName}.  The world coordinates produced by {\tt mapName} are the lon and lat of a sky coordinate system described by {\tt projection}.  The {\tt reprojectionName} is the name of a map that will transform coordinates from the gnomonic projection about the pointing center of this {\em exposure} into the projection about the {\em field} center.

\subsection{\tt Extension}
Each input catalog has an {\tt Extension} object.  Index integers specify which {\tt exposure} and {\tt device} this catalog comes from (remember that the exposure will be known to be have been taken with a particular instrument).  The  {\tt map} member points to the map from pixel coordinates to world coordinates (in the gnomonic projection for this field).  The {\tt wcs} points to a related object that can output {\tt SphericalCoords} given a pixel position.  This is the final product we are trying to produce!  We may wish to save a FITS-compatible version of this WCS when we are done: {\tt tpvOutFile} gives the name of the file this should be written to.  We need a WCS for the catalog to establish initial sky positions for the object---this is referenced by the {\tt startWcs} pointer, and can be a totally different functional form from the WCS we are trying to solve.

\subsection{\tt CoordAlign}
This is the class that controls the WCS parameter-fitting operation (in {\it Match.h, Match.cpp}).  The multithreading of the fitting operation is handled by this class's code.  The {\tt CoordAlign} is constructed with (1) a {\tt PixelMapCollection} that knows all of the coordinate transformations to be used for all the {\tt Detection}s and regulates which parameters are being held fixed or free, and (2) a list of pointers to {\tt Match}es whose $\chi²$ will be minimized by adjusting the WCS parameters.

The class has the following methods:
\begin{itemize}
\item {\tt remap()} recalculates the world coordinates of all objects in all {\tt Match}es, using the current WCS parameters.
\item {\tt sigmaClip(double sigThresh)} executes a single round of sigma-clipping on all {\tt Match}es, marking as outliers the most deviant detection in any {\tt Match} if it is more than {\tt sigThresh} clipping sigmas away from the {\tt Match} centroid.  You can choose whether this is done on only the reserved matches or the non-reserved ones.  Optionally you can have an entire {\tt Match} marked as useless if any one of its {\tt Detection}s is found to be an outlier.
\item {\tt chisqDOF()} calculates the $\chi²$ and number of degrees of freedom of the unclipped objects under the current WCS parameters.  Again you choose whether you're operating on the reserved or the un-reserved matches.
\item {\tt getParams(), setParams(), nParams()} manipulate the global parameter vector that is the union of all the parameters for all the maps in the {\tt PixelMapCollection}.
\item {\tt count()} methods let you know how many matches \& detections are in one or all of the catalogs.
\end{itemize}

FITTING???

\section{Inputs}
The program is called as

{\tt WCSFit} {???\it $\langle$field specs$\rangle\,\langle$exposure specs$\rangle\, [$parameter file$]\,[$parameter file$]\ldots$}

The standard input is read as additional parameter specifications.  If you have no additional parameters you will need to send an empty file to stdin.  

\subsection{Parameters}
Parameters can be specified one per line as {\it $\langle$parameter name$\rangle [{\tt=}] \langle$value$\rangle\; [ {\tt \#;}]$ comment.}
\begin{itemize}
\item {\tt matchRadius:} Distance (in arcsec) for friends-of-friends matching algorithm. (Default $=1$.)
\item {\tt useAffinities:} Force matches to be from the same affinity class ({\tt true}).
\item {\tt outName:} Filename for the output FITS tables ({\it match.cat}).
\item {\tt minMatch:} Minimum number of detections for a match to be retained (2).
\item {\tt selfMatch:} If false, reject all matches that have more than one detection from the same exposure ({\tt true}).
\item {\tt renameInstruments:} A translation table for instrument names.  This is a string having the format {\it $\langle$regex1$\rangle=\langle$replace1$\rangle, $ $\langle$regex2$\rangle=\langle$replace2$\rangle, \ldots.$}  Incoming instrument names are checked for matches with any of the regular expressions; if they match one, the name is translated into the replacement test.  Examples:
\begin{itemize}
\item {\tt renameInstruments = "i.* = i, r.* = r"} will change anything starting with {\tt i} or {\tt r} to the single-letter names.
\item {\tt renameInstruments "(..).* = \textbackslash{}1"} will use just the first two letters of any instrument name.  The translated instrument name will be used when looking up an instrument in the input {\tt PixelMapCollection} files.
\end{itemize}
\item {\tt stringAttributes, intAttributes, doubleAttributes:} comma-separated lists of any columns from the input exposure table that are to be passed on to the output tables.
\end{itemize}

\subsection{Files}
\label{infile}
{\tt WCSFoF} requires the names of two input files on the command line.  The first is the {\em field specification} file.  Each line of this file describes one field:
\begin{verbatim}
<Field name> <RA> <Dec> <extent>
\end{verbatim}
The field names should be unique and have no spaces.  The RA and Dec give the ICRS coordinates of the field center.  The extent gives (in degrees) the half-length of the square field that will contain all objects in this field.  The program will not properly match objects outside this square (unless they are assigned to another field).

The second input is the name of a FITS file with a single binary table extension containing our {\em filetable}.  Each row of the filetable describes one FITS file that contains one or more extensions that will serve as our input detection catalogs.  

The filetable will usually have been prepared by the {\em parse3.py} preprocessor. The filetable must have the columns specified below.  Basically each column of the filetable gives one of the attributes that we will assign to the extensions read for that row of the filetable.  

If a cell in the filetable begins with {\tt @}, it is assumed to give the keyword of an entry in the FITS catalog's header.  The desired value of the attribute is to be the value of the header card with this keyword.  The primary header of the FITS file is searched first, then overridden by any values found in the header of the catalog's binary table extension. An error results if this keyword is not present in the input catalog's header.

The filetable must have these columns:
\begin{itemize}
\item {\tt Filename:} (string) the path to the FITS file containing the input catalog(s).
\item {\tt Extension:} (int, default $=-1$) the extension number (zero-indexed) in the FITS file of the binary table detection catalog.  If this is a negative integer, then it is assumed that all of the extensions of the FITS file (except extension 0, the primary HDU) are valid binary table catalogs.  The code will sense if the FITS file is in the ``LDAC'' format produced by SExtractor, in which each catalog comes paired with another bintable holding the original image's header information.  Note that any time {\tt WCSFoF} needs to look for information in the input catalog headers, it will first look in the primary header of the FITS file, then override this with any values found in the header of the binary table extension (including any LDAC headers).
\item {\tt Field:} (string, default {\tt \_NEAREST}) the name of the field to which this file's catalogs belong.  The special value ``{\tt \_NEAREST}'' can be entered to assign this input file to the field nearest to the {\tt RA} and {\tt Dec} attributes.
\item {\tt Exposure:} (string) the name of the exposure to which this catalog(s) belong.
\item {\tt Instrument:} (string) the name of the instrument with which the catalog's detections were made.  The special values {\tt REFERENCE} and {\tt TAG} indicate the corresponding status for the extension.
\item {\tt Device:} (string) the name of the device with which the catalog's detections were made.  Note that for multi-extension input files this is almost certainly specified as the value to be found in a header entry for each extension.
\item {\tt RA, Dec:} (strings) the position of the center of this exposure or extension, in the traditional sexagesimal hours/degrees notation, {\it e.g.\/} ``12:24:30''  ``-30:04:02.8''.   Values are not needed if {\tt WCSFile = ICRS} (see below) and the {\tt Field} has been explicitly specified.
\item {\tt Select:} (string) specifies the selection criterion for objects from the input catalog to be used as detections.  It should be an expression that evaluates to a boolean.  For example, {\tt FLAGS == 0 \&\& ERRAWIN\_IMAGE<0.05}.  Variable names must correspond to columns in the extension's object catalog.  Names starting with {\tt @} are taken to be header keywords, and the value associated with the keyword in the extension (or primary) header is used.
\item {\tt Star\_select:} (string) another boolean expression that determines whether an object is considered a star or a galaxy.  Detections passing the star selection are assigned to the affinity class {\tt STELLAR.}
\item {\tt Affinity:} (string) the affinity class to which non-stellar detections from this catalog are assigned.
\item {\tt xKey, yKey:} (string) the name of the columns in the catalog binary table that give the $x$ and $y$ pixel coordinates of each detection.
\item {\tt idKey:} (string, default {\tt \_ROW}) the name of the column in the catalog binary table that contains a unique identifying integer for each detection in that catalog.  The special value {\tt \_ROW} will take the (zero-indexed) row number of the detection in the binary table as its identifier.
\item {\tt WCSFile:} (string) This gives the path to a file that, optionally, specifies the WCS for the extension(s) in this row of the filetable.  The options here are to enter:
\begin{itemize}
\item The name of a serialized {\tt PixelMapCollection} file.  In this case each extension of the catalog file will seek a map in this collection with the name {\it $\langle$exposure name$\rangle / \langle$device name$\rangle$.}  An error occurs if no map with this name is in the collection.
\item The name of an FITS-header-style ASCII file (as produced by {\sc SCAMP}), in which we expect to find a WCS specified with FITS conventions.  If the input catalog file has multiple extensions, the WCS for each are listed sequentially in the WCS file, seperated by the {\it END} keyword.
\item Nothing---in which case a WCS will be expected to be specified in the FITS headers of the catalog file.
\item The special value {\tt ICRS}.  This  means that the $x$ and $y$ coordinates in the catalog are {\em already} in the ICRS system and no WCS is needed.  These coordinates must be in {\bf degrees.}
\end{itemize}
\item Any attribute requested via the parameters {\tt stringAttributes, intAttributes,} or {\tt doubleAttributes} must be present in the filetable.
\end{itemize}

\section{Outputs}
\subsection{\tt Files}


\end{document}
