// Routines for FFTW interface objects
// This time to use Version 3 of FFTW.
// 	$Id: fft.cpp,v 1.10 2011/12/31 20:33:43 garyb Exp $	

#include "fft.h"
#include <limits.h>

using namespace fft;

#ifndef PI
#define PI 3.1415926535
#endif

KTable::KTable(int _N, 
	       double _dk, 
	       DComplex value) {
  if (_N<=0) throw FFTError("KTable size <=0");
  N = 2*((_N+1)/2);	//Round size up to even.
  dk = _dk;
  get_array(value);
  valid = true;
  scaleby=1.;
  return;
}


size_t
KTable::index(int i, int j) const {
  // adjust for XTable with origin in center.
  if (i<-N/2 || i>N/2 || j<-N/2 || j>N/2) 
    FormatAndThrow<FFTOutofRange>() << "KTable index (" << i << "," << j
				    << ") out of range for N=" << N;
  if (j<0) {
    j=-j; i=-i;	//need the conjugate in this case
  }
  if (i<0) i+=N;
  return i*(N/2+1)+j;
}

DComplex KTable::kvalLookup(int i, int j) const { // i is kx index, j is ky index, both in units of pixels dk
  validCheck();
  DComplex retval=scaleby*array[index(j,i)];
  if (i<0) return conj(retval);
  else return retval;
}

void
KTable::kSet(int i, int j, DComplex value) {
  validCheck();
  if (j<0) {
    array[index(i,j)]=conj(value)/scaleby;
    if (j==-N/2) array[index(-i,j)]=value/scaleby;
  }
  else {
    array[index(i,j)]=value/scaleby;
    if (j==0 || j==N/2) array[index(-i,j)]=conj(value)/scaleby;
  }
  return;
}

void
KTable::get_array(const DComplex value) {
  array = (DComplex*) fftw_malloc(sizeof(DComplex)*N*(N/2+1));
  for (int i=0; i<N*(N/2+1); i++)
    array[i]=value;
  return;
}

void
KTable::copy_array(const KTable& rhs) {
  if (array!=0 && N!=rhs.N) { // our array exists but is of different size
    fftw_free(array);
    array = 0;
  }
  N = rhs.N; // makes sure our array will be of same size
  if (!rhs.valid || rhs.array==0) { // if rhs array is not sane, our array should be null
    valid=false;
    fftw_free(array);
    array = 0;
    return;
  } else
    valid = true;
  if (array==0) array = (DComplex*) fftw_malloc(sizeof(DComplex)*N*(N/2+1)); // allocate space

  for (int i=0; i<N*(N/2+1); i++) // copy element by element
    array[i]=rhs.array[i];
  return;
}

void
KTable::kill_array() {
  fftw_free(array);
  array=0;
  return;
}

// Interpolate table (linearly) to some specific k:
DComplex 
KTable::kval(double kx, double ky) const {
  kx /= dk;
  ky /= dk;
  int i = static_cast<int> (floor(ky));
  double fy = ky-i;
  int j = static_cast<int> (floor(kx));
  double fx = kx-j;

  return (1-fx)*( (1-fy)*kvalLookup(j,i) + fy*kvalLookup(j,i+1)) +
    fx*( (1-fy)*kvalLookup(j+1,i) + fy*kvalLookup(j+1,i+1));
}

// Set table point nearest to some k
void
KTable::kSet(double kx, double ky, DComplex value) {
  kx /= dk;
  ky /= dk;
  int j = static_cast<int> (floor(kx+0.5));
  int i = static_cast<int> (floor(ky+0.5));
  kSet(i,j,value);
  return;
}
  
// Fill table from a function:
void
KTable::fill( DComplex func(const double kx, const double ky)) {
  DComplex *zptr=array;
  double kx, ky;
  DComplex *tmp1 = new DComplex[N/2];
  DComplex *tmp2 = new DComplex[N/2];

  // [ky/dk] = i = 0
  for (int j=0; j< N/2+1 ; j++) {
    kx = j*dk;
    *(zptr++) = func(kx,0);                  // [kx/dk] = j = 0 to N/2
  }
  // [ky/dk] = i = 1 to (N/2-1)
  for (int i=1; i< N/2; i++) {
    ky = i*dk;
    *(zptr++) = tmp1[i] = func(0,ky);        // [kx/dk] = j = 0
    for (int j=1; j< N/2 ; j++) {    
      kx = j*dk;
      *(zptr++) = func(kx,ky);               // [kx/dk] = j = 1 to (N/2-1)
    }
    *(zptr++) = tmp2[i] = func((N/2)*dk,ky); // [kx/dk] = j =N/2
  }
  // Wrap to the negative ky's
  // [ky/dk] = i = -N/2
  for (int j=0; j< N/2+1 ; j++) {
    kx = j*dk;
    *(zptr++) = func(kx,-N/2*dk);         // [kx/dk] = j = 0 to N/2   
  }
  // [ky/dk] = i = (-N/2+1) to (-1)
  for (int i=-N/2+1; i< 0; i++) {
   ky = i*dk;
   *(zptr++) = conj(tmp1[-i]);       // [kx/dk] = j = 0
    for (int j=1; j< N/2 ; j++) {
      kx = j*dk;
      *(zptr++) = func(kx,ky);         // [kx/dk] = j = 1 to (N/2-1)
    }
    *(zptr++) = conj(tmp2[-i]);      // [kx/dk] = j = N/2
  }
  return;
}


// Integrate a function over k - can be function of k or of PSF(k)
DComplex
KTable::integrate( DComplex func(const double kx, 
				 const double ky, 
				 const DComplex val)) const {
  DComplex sum=0.;
  DComplex val;
  double kx, ky;
  DComplex *zptr=array;
  // Do the positive y frequencies
  for (int i=0; i<= N/2; i++) {
    ky = i*dk;
    val = *(zptr++) * scaleby;
    kx = 0.;
    sum += func(kx,ky,val);	//x DC term
    for (int j=1; j< N/2 ; j++) {
      kx = j*dk;
      val = *(zptr++) * scaleby;
      sum += func(kx,ky,val);
      sum += func(-kx,-ky,conj(val));
    }
    kx = dk*N/2;
    val = *(zptr++) * scaleby;
    sum += func(kx,ky,val);	// x Nyquist freq
  }

  // wrap to the negative ky's
  for (int i=-N/2+1; i< 0; i++) {
    ky = i*dk;
    val = *(zptr++) * scaleby;
    kx = 0.;
    sum += func(kx,ky,val);	//x DC term
    for (int j=1; j< N/2 ; j++) {
      kx = j*dk;
      val = *(zptr++) * scaleby;
      sum += func(kx,ky,val);
      sum += func(-kx,-ky,conj(val));
    }
    kx = dk*N/2;
    val = *(zptr++) * scaleby;
    sum += func(kx,ky,val); // x Nyquist
  }
  sum *= dk*dk;
  return sum;
}

// Integrate KTable over d^2k (sum of all pixels * dk * dk)
DComplex
KTable::integratePixels() const {
  DComplex sum=0.;
  DComplex *zptr=array;
  // Do the positive y frequencies
  for (int i=0; i<= N/2; i++) {
    sum += *(zptr++) * scaleby;    // x DC term
    for (int j=1; j< N/2 ; j++) {
      sum += *(zptr) * scaleby;
      sum += conj(*(zptr++) * scaleby);
    }
    sum += *(zptr++) * scaleby;
  }
  // wrap to the negative ky's
  for (int i=-N/2+1; i< 0; i++) {
    sum += *(zptr++) * scaleby;    // x DC term
    for (int j=1; j< N/2 ; j++) {
      sum += *(zptr) * scaleby;
      sum += conj(*(zptr++) * scaleby);
    }
    sum += *(zptr++) * scaleby;
  }
  sum *= dk*dk;
  return sum;
}

// Make a new table that is function of old.
KTable*
KTable::function( DComplex func(const double kx, 
				const double ky, 
				const DComplex val)) const {
  KTable *lhs = new KTable(N,dk);
  DComplex val;
  double kx, ky;
  DComplex *zptr=array;
  DComplex *lptr=lhs->array;
  // Do the positive y frequencies
  for (int i=0; i< N/2; i++) {
    ky = i*dk;
    for (int j=0; j<= N/2 ; j++) {
      kx = j*dk;
      val = *(zptr++) * scaleby;
      *(lptr++)= func(kx,ky,val);
    }
  }
  // wrap to the negative ky's
  for (int i=-N/2; i< 0; i++) {
    ky = i*dk;
    for (int j=0; j<= N/2 ; j++) {
      kx = j*dk;
      val = *(zptr++) * scaleby;
      *(lptr++)= func(kx,ky,val);
    }
  }
  return lhs;
}

// Transform to a single x point:
double
KTable::xval(double x, double y) const { // assumes (x,y) in physical units
  // ??? check this:  don't evaluate if x not in fundamental period:
  x*=dk; y*=dk;
  if (x > 2*PI || y > 2*PI) throw FFTOutofRange(" (x,y) too big in xval()");
  DComplex I(0.,1.);
  DComplex dxphase=exp(I*x);
  DComplex dyphase=exp(I*y);
  DComplex phase(1.,0.);
  DComplex z;
  double sum=0.;
  // y DC terms first:
  DComplex *zptr=array;
  // Do the positive y frequencies
  DComplex yphase=1.;
  for (int i=0; i< N/2; i++) {
    phase = yphase;
    z= *(zptr++);
    sum += (phase*z).real();	//x DC term
    for (int j=1; j< N/2 ; j++) {
      phase *= dxphase;
      z= *(zptr++);
      sum += (phase*z).real() * 2.;
    }
    phase *= dxphase;		//j=N/2 has no mirror:
    z= *(zptr++);
    sum += (phase*z).real();
    yphase *= dyphase;
  }

  // wrap to the negative ky's
  yphase = exp(I*(y*(-N/2)));
  for (int i=-N/2; i< 0; i++) {
    phase = yphase;
    z= *(zptr++);
    sum += (phase*z).real();	// x DC term
    for (int j=1; j< N/2 ; j++) {
      phase *= dxphase;
      z= *(zptr++);
      sum += (phase*z).real() * 2.;
    }
    phase *= dxphase;		//j=N/2 has no mirror:
    z= *(zptr++);
    sum += (phase*z).real();
    yphase *= dyphase;
  }

  sum *= dk*dk*scaleby/(4.*PI*PI);	//inverse xform has 2pi in it.
  return sum;
}

void
// Translate the PSF to be for source at (x0,y0);
KTable::translate(double x0, double y0) {
  // convert to phases:
  x0*=dk; y0*=dk;
  // too big will just be wrapping around:
  if (x0 > PI || y0 > PI) throw FFTOutofRange("(x0,y0) too big in translate()");
  DComplex I(0.,1.);
  DComplex dxphase=exp(DComplex(0.,-x0));
  DComplex dyphase=exp(DComplex(0.,-y0));
  DComplex phase(1.,0.);

  DComplex yphase=1.;
  DComplex z;

  DComplex *zptr=array;

  for (int i=0; i< N/2; i++) {
    phase = yphase;
    for (int j=0; j<= N/2 ; j++) {
      z = *zptr;
      *zptr = phase * z;
      phase *= dxphase;
      zptr++;
    }
    yphase *= dyphase;
  }

  // wrap to the negative ky's
  yphase = exp(I*((N/2)*y0));
  for (int i=-N/2; i< 0; i++) {
    phase = yphase;
    for (int j=0; j<= N/2 ; j++) {
      z = *zptr;
      *zptr = phase* z;
      phase *= dxphase;
      zptr++;
    }
    yphase *= dyphase;
  }
  return;
}

//--------------------------------------------------
XTable::XTable(int _N, 
	       double _dx, 
	       double value) {
  N = 2*((_N+1)/2);	//Round size up to even.
  dx = _dx;
  get_array(value);
  valid = true;
  scaleby=1.;
  return;
}

size_t
XTable::index(int i, int j) const {
  // origin will be in center.
  i += N/2;
  j += N/2;
  if (i<0 || i>=N || j<0 || j>=N) 
    FormatAndThrow<FFTOutofRange>() << "XTable index (" << i << "," << j
				    << ") out of range for N=" << N;
  return i*N+j;
}

double XTable::xvalLookup(int i, int j) const { // i,j in pixel units dx; i is x index, j is y index
  validCheck();
  return scaleby*array[index(j,i)];
}

void
XTable::xSet(int i, int j, double value) {
  validCheck();
  array[index(i,j)]=value/scaleby;
  return;
}

void
XTable::get_array(const double value) {
  array = (double*) fftw_malloc(sizeof(double)*N*N);
  for (int i=0; i<N*N; i++)
    array[i]=value;
  return;
}

void
XTable::copy_array(const XTable& rhs) {
#ifdef DEBUG_TRACE
  cerr << "XTable::copy_array called with array=" << array << " N=" << N << " rhs.N=" << rhs.N << " rhs.array=" << rhs.array << " rhs.valid=" << rhs.valid << endl;
#endif
  if (array!=0 && N!=rhs.N) {
    fftw_free(array);
    array = 0;
  }
  if (!rhs.valid || rhs.array==0) {
    valid=false;
    fftw_free(array);
    array = 0;
#ifdef DEBUG_TRACE
    cerr << "XTable::copy_array exiting unsuccessfully" << endl;
#endif
    return;
  } else
    valid = true;
  if (array==0)   array = (double*) fftw_malloc(sizeof(double)*N*N);
  for (int i=0; i<N*N; i++)
    array[i]=rhs.array[i];
#ifdef DEBUG_TRACE
  cerr << "XTable::copy_array finished" << endl;
#endif
  return;
}

void
XTable::kill_array() {
  fftw_free(array);
  array=0;
  return;
}

// Interpolate table (linearly) to some specific k:
// x any y in physical units (to be divided by dx for indices)
double
XTable::xval(double x, double y) const {
  x /= dx;
  y /= dx;
  int i = static_cast<int> (floor(y));
  double fy = y-i;
  int j = static_cast<int> (floor(x));
  double fx = x-j;

  return (1-fx)*( (1-fy)*xvalLookup(j,i) + fy*xvalLookup(j,i+1)) +
    fx*( (1-fy)*xvalLookup(j+1,i) + fy*xvalLookup(j+1,i+1));
}

// Set table point nearest to some k
void
XTable::xSet(double x, double y, double value) {
  x /= dx;
  y /= dx;
  int j = static_cast<int> (floor(x+0.5));
  int i = static_cast<int> (floor(y+0.5));
  xSet(i,j,value);
  return;
}
  
// Fill table from a function:
void
XTable::fill( double func(const double x, const double y)) {
  double *zptr=array;
  double x, y;
  for (int i=0; i<N; i++) {
   y = (i-N/2)*dx;
   for (int j=0; j< N ; j++) {
     x = (j-N/2)*dx;
     *(zptr++) = func(x,y);
   }
  }
  return;
}

// Integrate a function over x - can be function of x or of PSF(x)
// Setting the Boolean flag gives sum over samples, not integral.
double
XTable::integrate( double func(const double x, 
			       const double y, 
			       const double val),
		   bool  sumonly) const {
  double sum=0.;
  double val;
  double x, y;
  double *zptr=array;

  for (int i=0; i< N; i++) {
    y = (i-N/2)*dx;
    for (int j=0; j< N ; j++) {
      x = (j-N/2)*dx;
      val = *(zptr++) * scaleby;
      sum += func(x,y,val);
    }
  }

  if (!sumonly) sum *= dx*dx;
  return sum;
}

double
XTable::integratePixels() const {
  double sum=0.;
  double *zptr=array;
  for (int i=-N/2; i< N/2; i++) 
    for (int j=-N/2; j< N/2; j++) {
      sum += *(zptr++) * scaleby;
    }
  sum *= dx*dx;
  return (double) sum;
}

// Transform to a single k point:
DComplex
XTable::kval(double kx, double ky) const {
  // check this:  don't evaluate if x not in fundamental period:
  kx*=dx; ky*=dx;
  if (kx > 2*PI || ky > 2*PI) throw FFTOutofRange("kval() args out of range");
  DComplex I(0.,1.);
  DComplex dxphase=exp(-I*kx);
  DComplex dyphase=exp(-I*ky);
  DComplex phase(1.,0.);
  DComplex z;
  DComplex sum=0.;

  double *zptr=array;
  DComplex yphase=exp(I*(ky*N/2));
  for (int i=0; i< N; i++) {
    phase = yphase;
    phase *= exp(I*(kx*N/2));
    for (int j=0; j< N ; j++) {
      sum += phase* (*(zptr++));
      phase *= dxphase;
    }
    yphase *= dyphase;
  }
  sum *= dx*dx*scaleby;
  return sum;
}

// Have FFTW develop "wisdom" on doing this kind of transform
void 
KTable::fftwMeasure() const {
  DComplex* t_array = 
    (DComplex*) fftw_malloc(sizeof(DComplex)*N*(N/2+1));
  // Copy data into new array to avoid NaN's, etc., but not bothering
  // with scaling, etc.
  for (int i=0; i<N*(N/2+1); i++)
    t_array[i] = array[i];

  XTable *xt = new XTable( N, 2*PI/(N*dk) );

  fftw_plan plan = 
    fftw_plan_dft_c2r_2d(N, N,
			 reinterpret_cast<fftw_complex*> (t_array), xt->array,
			 FFTW_MEASURE);
  if (plan==NULL) throw FFTInvalid();
  delete xt;
  fftw_free(t_array);
  fftw_destroy_plan(plan);
}

// Fourier transform from (complex) k to x:
XTable*
KTable::transform() const {
  // We'll need a new k array because FFTW kills the k array in this
  // operation.  Also, to put x=0 in center of array, we need to flop
  // every other sign of k array, and need to scale.

  DComplex* t_array = 
    (DComplex*) fftw_malloc(sizeof(DComplex)*N*(N/2+1));
  double fac = scaleby * dk * dk / (4*PI*PI);
  long int ind=0;
  for (int i=0; i<N; i++)
    for (int j=0; j<=N/2; j++) {
      if ( (i+j)%2==0) t_array[ind]=fac * array[ind];
      else t_array[ind] = -fac* array[ind];
      ind++;
    }

  XTable *xt = new XTable( N, 2*PI/(N*dk) );

  fftw_plan plan = 
    fftw_plan_dft_c2r_2d(N, N,
			 reinterpret_cast<fftw_complex*> (t_array), xt->array,
			 FFTW_ESTIMATE);
  if (plan==NULL) throw FFTInvalid();

  // Run the transform:
  fftw_execute(plan);
  fftw_destroy_plan(plan);
  fftw_free(t_array);
  return xt;
}

// same function, takes XTable reference as agrument 
void
KTable::transform(XTable& xt) const {

  // ??? check proper dimensions for xt ?
  Assert(N==xt.getN());

  // We'll need a new k array because FFTW kills the k array in this
  // operation.  Also, to put x=0 in center of array, we need to flop
  // every other sign of k array, and need to scale.

  DComplex* t_array = 
    (DComplex*) fftw_malloc(sizeof(DComplex)*N*(N/2+1));
  double fac = scaleby * dk * dk / (4*PI*PI);
  long int ind=0;
  for (int i=0; i<N; i++)
    for (int j=0; j<=N/2; j++) {
      if ( (i+j)%2==0) t_array[ind]=fac * array[ind];
      else t_array[ind] = -fac* array[ind];
      ind++;
    }

  fftw_plan plan = 
    fftw_plan_dft_c2r_2d(N, N,
			 reinterpret_cast<fftw_complex*> (t_array), xt.array,
			 FFTW_ESTIMATE);
  if (plan==NULL) throw FFTInvalid();

  // Run the transform:
  fftw_execute(plan);
  fftw_destroy_plan(plan);
  fftw_free(t_array);

  xt.dx = 2*PI/(N*dk);
  xt.scaleby = 1.;
  xt.valid = true;
}

void 
XTable::fftwMeasure() const {
  // Make a new copy of data array since measurement will overwrite:
  double* t_array = 
    (double*) fftw_malloc(sizeof(double)*N*N);
  // Copy data into new array to avoid NaN's, etc., but not bothering
  // with scaling, etc.
  for (int i=0; i<N*N; i++)
    t_array[i] = array[i];

  KTable *kt = new KTable( N, 2*PI/(N*dx) );

  fftw_plan plan = 
    fftw_plan_dft_r2c_2d(N,N,
			 t_array, reinterpret_cast<fftw_complex*> (kt->array),
			 FFTW_MEASURE);
  if (plan==NULL) throw FFTInvalid();

  delete kt;
  fftw_free(t_array);
  fftw_destroy_plan(plan);
}

// Fourier transform from x back to (complex) k:
KTable*
XTable::transform() const {

  KTable *kt = new KTable( N, 2*PI/(N*dx) );

  fftw_plan plan = 
    fftw_plan_dft_r2c_2d(N,N,
			 array, reinterpret_cast<fftw_complex*> (kt->array),
			 FFTW_ESTIMATE);
  if (plan==NULL) throw FFTInvalid();
  fftw_execute(plan);
  fftw_destroy_plan(plan);

  // Now scale the k spectrum and flip signs for x=0 in middle.
  double fac = scaleby * dx * dx; 
  size_t ind=0;
  for (int i=0; i<N; i++)
    for (int j=0; j<=N/2; j++) {
      if ( (i+j)%2==0) kt->array[ind] *= fac;
      else kt->array[ind] *= -fac;
      ind++;
    }

  return kt;
}
